# Entity Content Storage System

This document outlines the database-centric design for storing entity content within the Marain CMS. While entity *schemas* are defined in version-controlled YAML files and loaded into memory, the user-generated *content* for those entities is stored directly in the database in dedicated, type-specific tables.

This approach provides a robust, performant, and scalable storage solution that leverages the full power of the underlying SQL database.

## Core Principles

1.  **Database as the Source of Truth for Content**: All user-generated content resides in the database.
2.  **Structured, Typed Storage**: Content is stored in tables and columns that directly map to the entity and field types defined in the YAML schemas, enabling strong typing and indexing.
3.  **Predictable Naming Conventions**: Table and column names are generated deterministically from the entity and field IDs in the schemas.
4.  **Optimized for Queries**: The design is optimized for efficient querying, filtering, and retrieval of content.
5.  **Default Fields**: Every entity table includes default fields for UUID (universally unique identifier) and user tracking (defaults to 0 for system user).
6.  **Revision Tracking**: Versioned entities maintain a complete history of changes through revision tables and revision IDs.

## Table Naming Conventions

To ensure consistency and prevent naming collisions, the following naming conventions are strictly enforced:

### Entity Content Tables

Each entity schema results in a dedicated content table in the database. The table name is generated by prepending `content_` to the entity's `id`.

-   **Convention**: `content_<entity_id>`
-   **Example**: An entity with the `id` `article` will have its content stored in a table named `content_article`.

### Multi-Value Field Tables

Fields with a `cardinality` other than `1` (i.e., multi-value fields) store their data in a separate, dedicated table. This allows for clean one-to-many relationships without cluttering the main entity table.

-   **Convention**: `field_<entity_id>_<field_id>`
-   **Example**: An `article` entity has a multi-value `tags` field (of type `entity_reference`). The relationships will be stored in a table named `field_article_tags`.

### Field Reference Columns

For each multi-value field in an entity, the main entity table includes a `field_reference_<field_id>` column that stores the name of the corresponding multi-value table as a default value. This provides an explicit and intuitive way to discover child data by first referencing the parent entity and then following to the multi-value field tables.

-   **Convention**: `field_reference_<field_id>` with default value `field_<entity_id>_<field_id>`
-   **Example**: For a `multi` entity with a field `two` (cardinality: 2), the main table includes:
    - Column: `field_reference_two TEXT DEFAULT 'field_multi_two'`

## Database Schema Design

The following examples illustrate how YAML entity schemas are translated into database tables.

### Default Fields

Every entity table and multi-value field table automatically includes these default fields:

- **`id`**: Primary key for the record. For entities with a `title` field, this defaults to the title stripped of punctuation, converted to lowercase, with spaces replaced by underscores.
- **`uuid`**: A universally unique identifier (UUID v4) for the record, indexed for performance.
- **`user`**: Integer field tracking the user who created/modified the record (defaults to 0 for system user).
- **`rid`**: Revision ID for versioned entities (defaults to 1, increments with each update).
- **`last_cached`**: Timestamp indicating when the entity was last cached to the JSON cache (NULL if never cached).
- **`cache_ttl`**: Time-to-live in seconds for cache entries (defaults to 86400 seconds/24 hours).
- **`content_hash`**: SHA256 hash of all field values for detecting content changes.
- **`created_at`**: Timestamp of record creation.
- **`updated_at`**: Timestamp of last modification.

### 1. Main Entity Content Table (`content_`)

The main table for an entity stores all fields with a `cardinality` of `1`, plus the default fields.

**Example: `schemas/article.schema.yaml`**
```yaml
id: article
name: Article
versioned: true  # Enables revision tracking
fields:
  - id: title
    type: text
    required: true
  - id: slug
    type: slug
    required: true
  - id: body
    type: rich_text
  - id: author
    type: entity_reference
    target_entity: user
```

**Resulting SQL Table (`content_article`)**:
```sql
CREATE TABLE content_article (
    id TEXT PRIMARY KEY,          -- System-generated unique ID for the content item
    uuid TEXT NOT NULL UNIQUE,    -- Universally unique identifier for the record
    user INTEGER DEFAULT 0,       -- User who created/modified the record (0 = system)
    rid INTEGER DEFAULT 1,        -- Revision ID (increments with each update)
    last_cached TIMESTAMP,        -- When entity was last cached to JSON cache
    cache_ttl INTEGER DEFAULT 86400, -- Cache time-to-live in seconds (24 hours)
    content_hash TEXT,            -- Hash of all field values for change detection
    title TEXT NOT NULL,          -- Maps to the 'title' field
    slug TEXT NOT NULL UNIQUE,    -- Maps to the 'slug' field
    body TEXT,                    -- Maps to the 'body' field
    author TEXT,                  -- Stores the ID of the referenced 'user' entity
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_article_uuid ON content_article(uuid);
```

### 2. Multi-Value Field Table (`field_`)

A separate table is created for each field with `cardinality` not equal to `1`. This table links back to the parent content item and stores the multiple values for that field.

**Example: A `tags` field in the `article` entity**
```yaml
# In schemas/article.schema.yaml
fields:
  # ... other fields
  - id: tags
    type: entity_reference
    target_entity: tag
    cardinality: -1 # Unlimited tags
```

**Resulting SQL Table (`field_article_tags`)**:
```sql
CREATE TABLE field_article_tags (
    id TEXT PRIMARY KEY,                -- A unique ID for this specific relationship entry
    uuid TEXT NOT NULL UNIQUE,          -- Universally unique identifier for the record
    user INTEGER DEFAULT 0,             -- User who created/modified the record (0 = system)
    parent_id TEXT NOT NULL,            -- The ID of the parent content_article item
    value TEXT NOT NULL,                -- The ID of the referenced 'tag' entity
    sort_order INTEGER,                 -- Optional: for ordered lists
    FOREIGN KEY (parent_id) REFERENCES content_article(id) ON DELETE CASCADE
);

-- Indexes for efficient lookups
CREATE INDEX idx_field_article_tags_parent ON field_article_tags(parent_id);
CREATE INDEX idx_field_article_tags_uuid ON field_article_tags(uuid);
```

### 3. Field Reference Example

For entities with multi-value fields, the main table includes reference columns:

**Example: `schemas/multi.schema.yaml` with multi-value fields**
```yaml
id: multi
name: Multi
fields:
  - id: title
    type: text
    required: true
  - id: two
    type: text
    cardinality: 2  # Allows exactly 2 values
  - id: infinite
    type: text
    cardinality: -1  # Unlimited values
```

**Resulting SQL Table (`content_multi`)**:
```sql
CREATE TABLE content_multi (
    id TEXT PRIMARY KEY,
    uuid TEXT NOT NULL UNIQUE,    -- Universally unique identifier for the record
    user INTEGER DEFAULT 0,       -- User who created/modified the record (0 = system)
    rid INTEGER DEFAULT 1,        -- Revision ID (increments with each update)
    last_cached TIMESTAMP,        -- When entity was last cached to JSON cache
    cache_ttl INTEGER DEFAULT 86400, -- Cache time-to-live in seconds (24 hours)
    content_hash TEXT,            -- Hash of all field values for change detection
    title TEXT NOT NULL,
    field_reference_two TEXT DEFAULT 'field_multi_two',      -- Reference to multi-value table
    field_reference_infinite TEXT DEFAULT 'field_multi_infinite', -- Reference to multi-value table
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

In this design:
- `parent_id` creates the one-to-many link back to the main entity table.
- `value` stores the actual data for the field.
- `field_reference_*` columns in the parent table provide explicit references to the multi-value tables.
- `ON DELETE CASCADE` ensures that if an entity is deleted, its associated multi-value entries are automatically cleaned up.

This structured approach ensures:
- **Data integrity** through foreign key constraints
- **Discoverability** through field_reference columns
- **Performance** through proper indexing
- **Scalability** through normalized data structure

## Revision System

The Marain CMS includes a comprehensive revision tracking system for versioned entities. This system maintains a complete history of all changes made to entity content.

### Versioned Entities

Entities can be marked as versioned by adding `versioned: true` to their YAML schema definition. When an entity is versioned:

1. **Revision ID (rid)**: Every entity and multi-value field table includes a `rid` column that tracks the revision number.
2. **Revision Tables**: Separate tables store historical versions of the content.
3. **Automatic Tracking**: Updates automatically create revisions before applying changes.

### Revision Table Naming Conventions

Revision tables follow specific naming patterns:

- **Entity Revision Tables**: `content_revisions_<entity_id>`
- **Multi-Value Field Revision Tables**: `field_revisions_<entity_id>_<field_id>`

### How Revisions Work

1. **Initial Creation**: New entities start with `rid = 1`
2. **First Update**:
   - Current state (rid=1) is copied to the revision table
   - Main table is updated with new data and `rid = 2`
3. **Subsequent Updates**:
   - Current state is copied to revision table
   - Main table rid increments (2→3→4...)
4. **Result**: Main table always has the latest version, revision tables store complete history

### Example Revision Tables

For a versioned `article` entity:

**Main Table (`content_article`)** - Contains current version:
```sql
CREATE TABLE content_article (
    id TEXT PRIMARY KEY,
    uuid TEXT NOT NULL UNIQUE,
    user INTEGER DEFAULT 0,
    rid INTEGER DEFAULT 1,        -- Current revision number
    last_cached TIMESTAMP,        -- When entity was last cached to JSON cache
    cache_ttl INTEGER DEFAULT 86400, -- Cache time-to-live in seconds
    content_hash TEXT,            -- Hash of all field values for change detection
    title TEXT NOT NULL,
    slug TEXT NOT NULL UNIQUE,
    body TEXT,
    author TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Revision Table (`content_revisions_article`)** - Contains historical versions:
```sql
CREATE TABLE content_revisions_article (
    id TEXT,                      -- Original content ID
    uuid TEXT NOT NULL,
    user INTEGER,
    rid INTEGER NOT NULL,         -- Revision number at time of snapshot
    last_cached TIMESTAMP,        -- When entity was last cached to JSON cache
    cache_ttl INTEGER DEFAULT 86400, -- Cache time-to-live in seconds
    content_hash TEXT,            -- Hash of all field values for change detection
    title TEXT NOT NULL,
    slug TEXT NOT NULL,
    body TEXT,
    author TEXT,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    PRIMARY KEY (id, rid)         -- Composite key: content ID + revision number
);
```

### Revision API Endpoints

The revision system provides API endpoints for accessing historical data:

- **Get Specific Revision**: `GET /api/v1/entity/version/read/{entity_type}/{content_id}/{version_id}`
  - Retrieves a specific historical version of an entity
  
- **List All Revisions**: `GET /api/v1/entity/version/list/{entity_type}/{content_id}`
  - Returns a list of all revision IDs for a specific entity

### Benefits of the Revision System

1. **Complete Audit Trail**: Every change is tracked with who made it and when
2. **Rollback Capability**: Can restore any previous version if needed
3. **Content Comparison**: Can compare different versions to see what changed
4. **Compliance**: Meets regulatory requirements for data retention and auditing
5. **Performance**: Current data remains in main tables for fast access, historical data is segregated

### Important Notes

- Only entities with `versioned: true` in their schema will have revision tracking
- Revision tables are automatically created when the entity tables are created
- When dropping and recreating the database, all revision history is lost
- The `rid` column must be present in existing databases (requires rebuild if upgrading)

## Cache Management System

The Marain CMS includes built-in support for JSON caching through three dedicated fields that are automatically added to all entity tables. This system enables efficient caching strategies and change detection.

### Cache Fields

Every entity table includes these cache-related fields:

1. **`last_cached` (TIMESTAMP)**
   - Records when the entity was last cached to the JSON cache
   - NULL value indicates the entity has never been cached
   - Updated automatically when the entity is written to cache
   - Used to determine cache freshness

2. **`cache_ttl` (INTEGER)**
   - Time-to-live in seconds for cache entries
   - Defaults to 86400 seconds (24 hours)
   - Can be overridden per entity in the YAML schema
   - Used to determine when cached content should be refreshed
   - A value of 0 means no caching (always fetch fresh)

3. **`content_hash` (TEXT)**
   - SHA256 hash of all field values (excluding metadata fields)
   - Automatically calculated when entity is created or updated
   - Used for efficient change detection without comparing all fields
   - Excludes system fields (id, uuid, user, rid, timestamps, cache fields)

### Cache Workflow

1. **Cache Check**: When requesting an entity, check if `last_cached` + `cache_ttl` > current_time
2. **Cache Hit**: If cache is valid, serve from JSON cache
3. **Cache Miss**: If cache is expired or NULL, fetch from database
4. **Cache Update**: After fetching, update JSON cache and set `last_cached` to current time
5. **Change Detection**: Compare `content_hash` to detect if content has changed

### Example Cache Usage

```sql
-- Check if entity needs re-caching
SELECT id, last_cached, cache_ttl, content_hash
FROM content_article
WHERE id = 'my-article'
  AND (last_cached IS NULL
       OR datetime(last_cached, '+' || cache_ttl || ' seconds') < datetime('now'));

-- Update cache timestamp after caching
UPDATE content_article
SET last_cached = CURRENT_TIMESTAMP
WHERE id = 'my-article';
```

### Cache Configuration

The `cache_ttl` field can be configured at multiple levels:

1. **System Default**: 86400 seconds (24 hours)
2. **Entity Default**: Can be set in the entity YAML schema (future feature)
3. **Per-Record Override**: Can be modified for individual records

### Benefits

- **Performance**: Reduces database queries for frequently accessed content
- **Flexibility**: TTL can be adjusted per entity type or individual record
- **Efficiency**: Content hash enables quick change detection
- **Transparency**: Cache status is visible in the database for debugging
- **Compatibility**: Works with any JSON cache backend (ReDB planned for Task 16)